# 빅오
- 상한을 의미.
- 빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 **상한**을 나타낸다.
- 시간 복잡도: 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도
- 최고차항만 고려. 계수 무시.
- 종류
  - O(1)
    - 해시 테이블의 조회 및 삽입
  - O(n)
    - 입력값만큼 실행시간에 영향을 받음. 선형 시간 알고리즘.
  - O(logn)
    - 이진 검색
  - O(nlogn)
    - 효율 좋은 정렬 알고리즘(병합 정렬)
  - O(n ** 2)
    - 비효율 정렬 알고리즘(버블 정렬)
  - O(2 ** n)
    - 피보나치 수를 재귀로 계산하는 알고리즘
    - n**2보다 훨씬 큼
  - O(n!)
    - 가장 느린 알고리즘    

# 자료형
- None
- 숫자
  - 정수형
    - 정수: int
    - 불리언: boolean
  - 실수: float
- 집합형
  - 집합: set
- 시퀀스
  - 불변
    - 문자열: str
    - 튜플: tuple
    = 바이트: bytes
  - 가변
    - 리스트: list(자유롭게 추가, 삭제 할 수 있는 동적 배열)
      - 연속한 메모리에 객체의 주소를 저장함
      - 리스트 vs 튜플
        - 리스트는 동적배열, 튜플은 **정적배열**
          - 튜플은 배열의 크기와 원소를 변경할 수 없음
- 매핑
  - 딕셔너리: dict

- 파이썬은 원시 타입을 지원하지 않는다. 파이썬은 원시 타입의 속도를 포기하는 대신, 객체의 다양한 기능과 편의성을 택함
  - 즉, 파이썬의 **모든 것이 객체**다! 
  - 파이썬에서 변수를 할당하는 작업은 해당 객체에 대해 참조를 한다는 의미
  - 불변 객체: str, int, float, boolean, tuple
  - 가변 객체: list, set, dict

# 자료구조
> 메모리를 효율적으로 사용하며 빠르고 안정적으로 데이터를 처리하는 것을 목표로 상황에 따라 유용하게 사용될 수 있도록 특정 구조를 이루고 있는 것. - 일차원인 컴퓨터 메모리를 현실에 대응되도록 구조를 만드는 것.
## 선형 자료 구조
- 데이터 요소가 순차적으로 배열되는 자료구조
1. 배열(Array)
  - 연관된 데이터를 연속적인 형태로 구성된 구조
  - 배열에 포함된 원소는 순서대로 index가 붙는다.
  - 고정된 크기를 가지며 일반적으로 동적으로 크기를 늘릴 순 없다.
  - 원하는 원소의 index를 알고 있다면 O(1) 시간에 찾을 수 있음
  - 단점
    - **특정 INDEX를 삭제할 경우 빈 공간 발생** -> 따라서 연속적인 특징 유지 위해 그 뒤의 인덱스 원소들을 Shift 해줘야하는 비용 발생. 최악의 경우 O(n)의 시간복잡도를 가짐
    - 첫번째 자리나 중간에 원소를 삽입할 경우에도 O(n)의 시간복잡도 지님.
  - 따라서 추가/삭제가 반복되는 로직이면 배열 x. 탐색이 많은 경우 유리.
  - 스택, 큐, 힙, 해시 테이블, 행렬 등을 만들 때 사용한다.
  - 정렬 알고리즘을 구현할 때도 사용한다.
2. 스택(Stack)
  - LIFO, 가장 늦게 들어 간 요소가 가장 먼저 나오는 구조.
  - 사용사례
    - 웹 브라우저 방문기록(뒤로가기)
    - 실행 취소(UNDO, 컨트롤 + 제트)
    - 역순 문자열 만들기
    - 후위 표기법 계산 (연산자가 피연산자 뒤에 위치하는 표기법, AB+)
    - 재귀적 알고리즘
3. 큐(Queue)
  - 선입 선출(가장 먼저 들어온게 가장 먼저 나간다, FIFO)
  - 뒤에서 자료 삽입, 앞에서 자료 삭제
  - 사용사례
    - 프린터 출력 처리
    - BFS
    - 콜센터 고객 대기 시간
    - 캐시 구현
    - 선입선출이 필요한 대기열(은행표)
    - 컴퓨터 운영체제의 테스크 스케쥴링(가장 간단한 형태의 선입선처리 스케쥴링 정책)
4. 연결리스트(Linked List)
  - 추가, 삭제가 반복되는 로직에 비효율적인 배열의 문제점을 해결하기 위한 자료구조
  - 각 요소를 **포인터로 연결**하여 관리하는 선형 자료구조. 각 요소는 노드라고 부르며, 데이터 영역과 포인터 영역으로 구성됨.
    - 즉 노드에는 값과 다음 노드의 주소가 저장되어 있음
  - 메모리가 허용하는 한 요소를 제한 없이 추가할 수 있음
  - 탐색은 O(n) 소요
  - 요소 추가, 제거는 O(1) 소요
  - 단점
    - 논리적 저장 순서와 물리적 저장 순서가 일치하지 않아 어떤 원소를 삭제 또는 추가할 때, 그 원소를 찾기 위해 O(n)의 시간이 추가적으로 발생
      - 결국 탐색, 삽입, 삭제에도 O(n)의 시간복잡도를 지님. 연결 리스트는 트리 구조의 기본이며 트리에 사용되었을 때 유용성이 드러남.
  - 종류
    1. 단일 연결 리스트: head부터 tail까지 단방향으로 이어지는 구조
    2. 이중 연결 리스트: 양방향으로 이어지는 구조(다음과 이전을 가리킬 수 있음)
    3. 환형 연결 리스트: tail이 head를 가리켜 원형으롤 연결되는 구조


## 비선형 구조
> 원소 간 다대다 관계를 가지는 구조로 계층적 구조나 망형 구조를 표현하기에 적절

1. 그래프
  - 정점과 정점 사이를 연결하는 간선으로 이루어진 비선형 구조
  - 무방향 그래프: 양방향
  - 방향 그래프: 방향성이 존재
2. 트리
  - 방향 그래프의 일종. 정점을 가리키는 간선이 하나 밖에 없는 구조. 계층적 관계 표현하는 자료 구조.
  - 루트 노드를 제외하고 모든 노드는 반드시 하나의 부모 노드를 가짐
  - 노드가 n개면 n-1 간선을 가짐
  - 루트에서 특정 노드로 가는 경로는 유일함.

  - Binary Tree
    - 각 노드가 최대 2개의 자식을 가지는 트리.
    - 정점이 n개인 이진트리는 최악의 경우 높이가 n
    - 정점이 n개인 포화 또는 완전 이진트리의 높이는 logN
    - 종류
      - 완전 이진 트리: 마지막 레벨을 제외하고 모든 정점이 채워져 있는 트리
      - 포화 이진 트리: 마지막 레벨까지 모두 채워진 이진 트리
      - 편향 트리: 한 방향으로만 노드가 이어짐
  
  - BST(Binary Search Tree)
    - 효율적인 탐색 위해서 데이터를 저장하는 규칙을 가지며 해당 규칙은 특정 데이터의 위치를 찾는데 사용됨.

  - 우선순위 큐
    - 우선 순위가 높은 요소가 먼저 나가는 큐.
    - 힙 != 우선순위 큐
    - 힙(Heap)
      - 우선 순위큐를 구현하기 위한 가장 적절한 자료구조
      - 이진 트리 형태를 가지며 우선 순위가 높은 요소가 먼저 나가기 위해 요소가 삽입, 삭제 될 때 바로 정렬되는 특징이 있음
      - 루트가 가장 큰 값이 되는 최대 힙과 루트가 가장 작은 값이 되는 최소 힙이 있다.
      - 추가
        - 요소가 추가 될 때는 트리의 가장 마지막에 정점이 위치하고, 부모 노드보다 우선 순위가 높다면 부모 노드와 순서를 바꿈. 이 과정을 반복하면 결국 가장 우선 순위가 높은 노드가 루트가 됨.
        - 완전이진트리의 높이는 logN이기에 힙의 요소 추가 알고리즘은 O(logN)의 시간 복잡도를 가짐.
      - 제거
        - 요소 제거는 루트 노드만 가능
        - 루트 노드가 제거된 후 마지막 정점이 루트에 위치함
        - 루트 노드의 두 자식 노드 중 더 우선순위가 높은 노드와 바꿈
        - 두 자식의 노드가 우선순위가 더 낮을 때까지 반복
        - 완전 이진 트리의 높이는 logN이라 시간복잡도 또한 그러함

  - B Tree
    - 데이터베이스에서 널리 사용되는 트리 자료구조의 일정(다차원 트리), 이진트리 확장판. 더 많은 수의 자식을 가질 수 있게 한 것.

  - B+ Tree
    - 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드가 추가로 있음.

3. 해시 테이블
  - 키와 값을 받아 해싱하여 나온 index에 값을 저장하는 선형 자료구조
  - 삽입 O(1)이며, 키를 알고 있다면 삭제, 탐색도 O(1)로 수행.
  - 한정된 배열 공간에 key를 index로 변환하여 값들을 넣게 됨.
  - 언어에 따라 해시 맵, 사전 등으로 불림
  - 해시 충돌 해결
    1. 개방 주소법(open addressing): 다른 해시 버킷에 해당 자료를 삽입
    2. 분리 연결법(separate chaining): 다른 해시 버킷이 아니라 해당 해시 버킷에 여러 개의 데이터를 연결하는 방식으로 트리를 이용한 방식과 연결 리스트를 이용한 방식이 있음.


# 알고리즘
## 정렬 알고리즘
1. 선택 정렬(Selection Sort)
  - 현재 위치에 들어갈 값을 찾아 정렬하는 배열
  - 배열의 가장 작은 값을 가지는 인덱스를 찾아서 가장 작은 값을 앞에서부터 채워나가면서 정렬하는 방식.
  - 로직
    1. 정렬 되지 않은 인덱스의 맨 앞에서부터, 이를 포함한 그 이후의 배열값 중 가장 작은 값 찾아가기
    2. 가장 작은 값을 찾으면, 그 값을 현재 인덱스의 값과 바꿈
    3. 위의 과정 반복
  - 전체 비교 진행: O(n**2) 
2. 삽입 정렬(Insertion Sort)
  - 현재 위치에서 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아, 그 위치에 삽입하는 배열 알고리즘
  - 최소값을 찾아서, 이하 배열들의 원소와 비교하여 자신이 위치해야 할 곳을 찾아 삽입해나가며 정렬하는 방식
  - 로직
  - 이미 정렬되어 있는 경우, 한번씩 밖에 비교하지 않으니까 : O(n)
  - 최악의 경우는 O(n**2)
3. 병합 정렬
  - 분할 정복 방식
  - 큰 문제를 반으로 쪼개 문제를 해결해내가는 방식
  - 배열의 크기가 1보다 작거나 같을 때까지 반복.
  - 배열을 반씩 쪼개서 하나의 원소를 가진 배열로만 만든 후, 비교를 통해 각 배열을 정렬하여 병합하여 최종 정렬된 배열을 구하는 정렬방식
  - 배열을 반씩 쪼개며 정렬을 하고 다시 그것을 병합하는 방법이라 O(nlogn)
4. 퀵 정렬
  - 병합 정렬과 로직이 유사. 기준이 되는 기준점을 가지고 앞/뒤 배열로 쪼개서 각 앞/뒤 배열을 기준값보다 작은 수를 앞으로 몰고 기준값보다 큰 수를 재귀함수를 통해 뒤로 몰아가는 정렬 방식
  - O(nlogn), 추가 메모리 공간을 필요로 하지 않는다(O(logn))
5. 힙 정렬
  - 최대 힙 트리나 최소 힙 트리를 구성해 정렬하는 방법
  - 내림차순은 최대 힙으로 구성, 오름차순은 최소힙으로 구성
  - nlogn
  - 가장 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇개만 필요할 때
6. 버블 정렬
  - 매번 연속된 두 개의 인덱스를 비교하여, 정한 기준의 값을 뒤로 넘겨 정렬하는 방법
  - 처음부터 끝까지 자신과 자신 다음 데이터를 비교해가면서 가장 큰 수를 맨 뒤로 보내는 식으로 동작하는 알고리즘
  - O(n**2)
7. 팀소트