# 등산로 안내 사이트 프로젝트
> 등산 한 번 해볼까? 마음은 먹지만 막상 가려니 찾을 때부터 덜컥 막힙니다. 어떤 등산로가 내게 맞을까? 집과는 가까울까? 왕복 몇 시간이지? 블로그 등산로 후기를 뒤적거리지만, 정보가 파편화되어 있어 여간 불편한 게 아닙니다. 정보가 한눈에 들어오지도 않고 머릿속은 뒤죽박죽입니다. 모두 이런 불편한 경험 한번쯤은 있지 않나요? 

> **그런 불편함을 해결하고자 등산로 안내 사이트를 만들었습니다.**

## 프로젝트 기간
- 2023.05 ~ 2023.06

## 팀원
### 프론트엔드
- 최지원
- 정세호
### 백엔드
- 장하늬(조장)
- 임성주
- 김규리

## 기술 스택
- Django, PostgreSQL, JavaScript, HTML, CSS, AWS EC2 등

## 유저 페르소나
1. 등산로를 간편하게 조회하고 싶은 고객
2. 등산 후기를 공유하고 싶은 고객

## 주요 기능
- 100대 명산 및 등산로 조회
  - 지역 및 테마 필터링
- 등산로 개인 기록(다녀온 곳 체크 기능)
- 등산 후기 작성

## 나의 역할
- 조장
- DB 생성 및 구축
  - 공공정보를 활용하여 산 및 등산로 DB 구축
  - 지리정보(위도, 경도, 고도 좌표)를 활용하기 위해 postGIS를 활용
    - 소요시간, 총거리 등을 계산함
- 카카오 MAP API를 이용한 등산로 좌표 시각화
- 산 관련 기능 구축
  - 명산 검색 페이지
  - 명산 및 등산로 리스트 페이지
  - 명산 및 등산로 상세 페이지
  - GPX 다운로드 기능
- 배포
  - AWS EC2, Nginx, uWSGI를 활용하여 배포함.

## Keep: 프로젝트 완료 후에도 간직하고 싶은 잘했던 것 / 좋았던 것

- Django 숙련도 상승: Django View를 작성할 때, 함수 기반 뷰(FBV)와 클래스 기반 뷰(CBV)를 적절히 활용하여 기능을 구현했다. 특히, CBV를 활용함으로써 CBV의 종류와 구성, 상속에 대한 이해가 깊어졌고, 상속이라는 강력한 무기를 이용하여, 단순한 리스트 페이지나, 상세 정보 페이지는 `DetailView`와 `ListView`를 활용하여 개발 프로세스 속도를 높일 수 있었다. 게다가 코드를 확장할 때 유용했다. 예를 들어 등산로 코스 리스트를 나타내는 페이지에서 `ListView`를 상속받아 속성 중 하나인 `get_queryset()`을 오버라이딩하여 여러 개의 필터링 기준을 손쉽게 구현할 수 있었다.
- 공간 정보 데이터 활용능력 습득: 등산로를 지도 위에 시각적으로 구현하기 위해, 공간 데이터(좌표)를 다룰 필요가 있었다. 또한 선별한 공공 데이터인 등산로 GPX 데이터와 100대 명산 정보 데이터를 가공하여 DB를 생성하기 위해, QGIS(지리 정보 체계 응용 프로그램)와 PostgreSQL과 익스텐션인 PostGIS를 활용했다. 
  - QGIS에서 파이썬 스크립트를 활용하여 GPX 데이터에 각 산 별 명칭과 코스 명칭을 부여하고, 통합하여 쉐이프 파일로 변환하였다.
  - 변환한 쉐이프 파일(.shp)로 DB를 생성하고, 산과 코스 테이블을 1:N으로 연결하는 등 일련의 활동을 통해 DB 설계와 데이터 가공하는 경험을 할 수 있었다.
  - 또한 PostGIS에 포함된 공간 쿼리를 활용하여, 코스 별 총 거리와 소요시간을 구할 수 있었다.
  - 마지막으로 카카오 MAP API를 활용하여 geoJson으로 변환시킨 좌표로 코스는 선으로 시각화하고, 이정표(wayPoint)는 점으로 시각화하여 고객들이 등산로를 한눈에 볼 수 있게 만들었다.
- AWS를 활용한 배포: AWS EC2로 가상 서버를 연 뒤, 로컬과 동일한 환경을 구축했다. 그리고 Nginx와 uWSGI를 이용하여 가상 서버를 꺼놔도 유저가 서비스를 이용할 수 있게 만들었다. 
- 새로운 기술 습득에 대한 자신감: 새로운 기술에 대한 막연한 두려움이 사라졌다. 모르면 배우면 된다. 그리고 사용하고 확인하고 실패했으면, 수정하고, 성공하면 성공한 이유를 확인하며 공부한다. 그러면 어느새 그 기술을 쓰고 있다.
- DB 수정을 통한 DB 설계 능력 습득(속도 개선을 위하여 한 일)

- UI/UX 설계 협업: 1차,2차 프로젝트에서 가장 아쉬웠던 점을 개선했다. 백엔드는 서버 사이드만 집중하면 된다는 생각에 프론트엔드 쪽에 UI/UX 설계를 맡겼던 과거를 반성하고, 이번에는 팀원 모두와 ERD부터 UI/UX(피그마 활용) 설계를 모두 함께했다. 개발 시작 일자가 늦어졌지만, 초반에 이렇게 서로의 생각을 공유하여 통일 시키는 게 매우 중요하다. 왜냐하면, 똑같은 내용을 전달하더라도 사람마다 생각을 다르기 때문이다. 그렇게 되면 백엔드에서 전달하는 데이터와 프론트엔드가 얻고 싶어하는 데이터의 성질이 달라지고, 이는 다시 코드를 보수해야하는 시간 자원 낭비로 이어진다. 초반부터 의견을 일치시키고 육안으로 확인함으로써 그런 시간 낭비를 줄일 수 있었다.

## Problem: 프로젝트 중 겪엇던 어려움(기술, 소통, 협업, 에러 등 프로젝트 진행 관련 그 어느 것이든) / 프로젝트 완료 후에도 아쉬움으로 남는 것
- 기술 측면
  - 통일된 환경 구축의 어려움: 산에 관련된 DB가 프로젝트의 핵심 리소스이며, 공간 데이터를 활용하기 위해서 외부 DB를 이용할 필요가 있었으므로 모두가 동일한 DB 환경을 구축할 필요가 있었다. 가장 이상적인 방법은 도커를 활용하여 가상환경을 공유하는 것이었지만, 한 달 안에 더 중요한 기술들을 습득하고 어플리케이션을 개발해야했기에 시간자원이 부족하다고 판단하여, 백업 데이터를 공유하는 단순무식한 방법을 이용했다. 산과 관련된 DB 구축을 하며 매일 같이 백업 데이터를 생성하고 공유했다. 난점은 PostgreSQL이 설치되지 않는 조원 한 명이 있었던 점이다. 해결하는 데 3일 이상이 소요됐다. 만약, 도커를 활용했다면 낭비하지 않을 시간이었을 텐데, 그점이 가장 아쉬웠다.
    - 프로젝트가 끝난 후, 도커를 공부하기로 결심한 계기였다. 
  - 에러 원인 찾기의 어려움(2차 프로젝트에서 깨달은 점이므로 2차 프로젝트 회고록으로 넘기자)
    - 오타뿐만 아니라, 코드 한 문장으로 인해 생기는 오류를 몇 시간이고 찾다 해결한 경험이 많았다.
    - 네트워크와 http 지식이 있었다면, 금새 찾을 수 있는 부분도 chat GPT에 의존하면서 허송세월을 보낸 적도 있다.
    - 여기서 얻은 교훈은 다음과 같다.
      - 분기점마다 `print()`를 찍어보자. 어느 부분에서 작동하지 않는지 확인 할 수 있다.
      - TDD를 공부하자. 테스트 주도 개발을 통해, 에러 핸들링이 손쉬워질 것이다.
  - 프론트엔드 언어 능력 미숙(geoJson을 JS에 활용하는 것)
    - 세 번에 걸친 프로젝트에서 백엔드를 담당했기 때문에, css, html, Js쪽 부분이 미숙했다. 총 5명의 인원 중 두 명이 프론트엔드 였고 나 포함 3명이 백엔드였기 때문에, 상대적으로 프론트엔드 쪽 업무량이 많았으므로, 맵에 코스를 시각화하기 위한 Js를 내가 담당해야 했다. 단순하게 생각하면 위도, 경도, 고도를 담고 있는 데이터를 점(point)로 맵에 전부 찍고 선(string)으로 연결하면 되었다. 그러나 그렇게 하려면 geometry로 가공한 DATA를 프론트사이드로 response하고, js에서 해당 데이터를 파싱하는 부분해야했다. 즉, db에 담겨 있는 데이터를 Js 입맛에 바꿔야 했다. 하지만 거시적 관점에서의 이해없이 무작정 부딪혀 가며 코드를 짰기 때문에, 번번히 작동하지 않는 코드의 쓴 맛을 맛봐야 했다. 돌이켜 보면 Js 코드 하나 하나를 뜯어보고 생각하며 작성했다면 금방 해결 했을 부분들이다.
  - DB 가공: 소요시간, 거리 구하기. 경로 명칭 만들기.
    - 프로젝트의 요구사항에 로우 데이터는 부적합했다. 따라서 요구사항에 맞게 필드를 수정, 데이터 형변환 그리고 기존 데이터를 이용해 새로운 필드를 만들 필요가 있었다. 단적으로 100대 명산과 각 명산의 코스 데이터를 관계 지을 필요가 있었고, 코스 데이터의 거리와 해당 코스 편도 소요시간을 구할 필요가 있었다. 기존 데이터로는 얻을 수 없었다. 하지만 등산 정보를 전달하는 사이트이니만큼 소요시간과 소요거리 데이터는 필수였다.
  - CS 지식 부족:
  - filtering과 sorting: 동일한 화면에서 필터링과 정렬을 동시에 실행하여 쿼리를 솎아내는 건 할 수 있었지만, 탐색 페이지에서 필터링을 실시하고 다음 페이지에서 정렬을 하려하는 데 어려움을 겪었다. 필터링한 데이터에서 정렬을 하려 했으나, 정렬을 하는 순간, 필터링이 풀리고 전체 데이터에 대한 정렬이 실행됐기 때문이다. 문제의 원인은 http 메서드에 있었다. 필터링할 때도 get을 썼고, 정렬할 때도 get을 이용했다. 따라서 정렬하는 순간, 기존 데이터가 초기화되어 전체 데이터가 정렬되어 뽑혀 나온 것이다.
  - 기능 구현이 어려워, 누더기처럼 붙은 코드들(리팩토링 필요):

- 소통 및 협업 측면
  - 성향의 차이점
    - 나는 주로 음성 대화를 통해 의기투합하고, 협업하는 성향이었고, 으쌰으쌰하는 분위기 속에서 팀을 이끌고 코딩하는 편이었다. 하지만 이번 조원들은 상대적으로 조용했고, 스몰토크를 즐기기보다는, 코딩에 집중하고 필요한 대화는 주로 메세지로 주고 받는 걸 선호했다. 
    - 팀장으로서 분위기를 살리지 못하고, 팀 기량을 높이지 못했다는 생각에 괴로웠다. 
    - 특히 의사소통이 원활하게 되지 않아서, 컨벤션이 지켜지지 않거나, 깃 관리가 적절하지 안 될 때, 공지했음에도 모르는 조원이 속출할 때 좀더 적극적으로 대화했으면 하는 바람이 있었다.

- 다양한 프로그램을 조합했을 때, 어떤 부분이 오류 나는지 몰라 한참을 헤맸다. 의존성, 네트워크 등등, CS 공부 필요성을 느꼈다.
- 백엔드에만 집중하다보니, 프론트엔드 쪽 언어 능력이 미숙했다. 특히 JS는 아직도 어렵다.

## Try: Problem 중 해결된 사항에 대한 해결 방법 / 해결되지 않은 사항에 대한 피드백
- CS 공부: 백엔드를 하면서 django(python)든 node.js(Js)든 개발 프레임워크가 중요한 게 아니고, 네트워크나 서버 사이드에 대한 cs지식이 중요함을 깨달았다. 클라이언트의 요청과 서버의 응답이란 커다란 틀 안에서 어떤 로직으로 돌아가는 지 거시적 관점 속에서 개발을 할 필요가 있다. 거기서부터 시작해서 최적화, 클린코드, 에러 핸들링이 시작된다. 
  - 현재, 정보처리기사 필기 공부를 하며 일부 지식을 쌓을 수 있다.
  - 차후, 실기 공부 및 운영체제, http, 네트워크 공부를 하여 백엔드로서 탄탄한 지반을 다질 것이다.
- 문서화의 필요성과 도커의 필요성: 같은 환경을 조성하기 위해, 팀원 모두 시간을 내어 DB부터 geoDjango를 설치했다. 하지만, 육성으로 설명하고 방송을 통해 안내했기때문에 똑같은 말을 여러번 반복해야했고, 시간을 상당히 낭비했다. 게다가 조원 한 명의 환경에서 DB 설치 오류가 나서 며칠을 소모했다. 막판에는 조원이 프로젝트를 포기하려했다. 서로 따로 시간을 내어 진정시키고, 튜터에게 자문을 구하고, 이것저것 시도했다. 그리고 결국, 설치에 성공했다. 이런 경험을 통해 문서화와 도커의 필요성을 절실히 느꼈다.
  - window 환경에선 geoDjango를 설치하기 힘들다. 내가 미리 설치 문서를 작성하여, 배포하였다면, 똑같은 말을 반복할 필요도 없고, 모두 동일한 문서를 보며 각자 환경에 맞게 설치했을 테니 시간낭비도 없었을테다. 다음 프로젝트에서 똑같이 이런 상황이 연출된다면, 문서화할 것이다.
  - 각 환경이 동일 할 수 없으니 가상환경을 조성하고 공유하는 게 개발 효율에 얼마나 도움이 되는지 깨달았다. 차후 도커 공부를 할 것이다.
- 세션 저장으로 필터링 및 정렬 해결: 동일한 get 메서드로 해결하기 어렵다고 판단하여, 탐색 페이지에서 post로 데이터를 바디에 담아 넘겼고, 세션에 필터링한 산의 pk를 저장했다. 그리고 get 메서드로 정렬을 요청할 때, 해당 세션에서 pk 리스트를 뽑아내어 산의 데이터를 솎아내고 정렬했다. 그리고 필터링 리셋 버튼을 누르면 세션에서 키를 삭제하는 방식으로 구현했다.
  - 여전히 이 방법이 최선이었는지는 의문이다. 세션, 쿠키 및 캐시, 그리고 http 메서드를 자세히 공부하여 더 나은 방법으로 개선 시킬 것이다.
- 성향 차이에 따른 맞춤 개발문화 활용: 우선 인정해야했다. 성향이 다르다. 따라서 서로의 성향을 존중하고, 기존에 가지고 있던 개발문화에 대한 내 고정관념을 버렸다. 이전처럼 스몰토크로 시작하여, 음성으로 의견을 나누고 아이디어를 브레인스토밍 방식으로 제시하기 보다는, 스몰토크 시간을 확 줄이고 데일리 스크럼 양식에 자신의 생각을 적고 오늘 할일을 적을 시간을 충분히 줬다. 확실히 즉석에서 말로 할 때보단, 여러 의견이 나왔고, 현 문제점을 빠르게 파악할 수 있었다. 두 번째로 부드럽고 간적접인 의사소통 방식보다는 직접적이며 정보전달이 확실한 의사소통 방식을 차용했다. 예를 들어, "이런 기능이 이런이런 이유로 차용하면 편할 거 같은데, 다들 어떻게 생각하시나요?"보다는, "이런 이런 기능이 이런 이유에서 필요할 것 같습니다. 00님은 어떻게 생각하시나요?"라고 의견을 구했다.
  - 이런 협업 경험을 통해서 책이나 인터넷에서 흔히 말하는 개발문화가 100% 정답은 아니란 점을 깨달았다. 팀에서 이끌어낼 수 있는 시너지를 분명히 정의하고 이에 맞는 개발문화를 조성하여 협업효율을 올릴 필요가 있다. 개발문화란 결국, 개발을 위한 문화니까.
- DB 가공: 결국, PostGIS의 공간 함수를 이용해서 소요시간과 거리를 구했다. 하지만 정확도가 높다고 장담할 순 없었고, 프로젝트가 끝날 때까지 찝찝한 마음을 금할 수 없었다. 어떻게 하면 정확도를 높일 수 있을까? 
  - 우선, 가장 적합한 로우 데이터를 확보하는 게 급선무다. 하지만, 이상 요구사항에 맞는 데이터를 구할 수 없었다.
  - 둘째로, 집단지성의 힘을 빌리는 것이다. 유저가 다녀와서 남긴 후기에 편도 소요시간 정보를 작성하게 만들면 어떨까? 데이터가 많이 쌓일 수록, 정확도는 절로 올라갈 것이다. 하지만, 이는 도박이다. 인간의 기억에 의존하는 건 데이터 타당도에 치명적이다.
  - 셋째, 직접 데이터를 만드는 것이다. 이는 비용과 시간이 드는 방법이긴 하지만, 확실한 방법이다. 각 코스별로 정보를 검색하고 직접 기입하는 것, 하지만 개발자의 관점에서는 상당히 별로인 방법이다.
- 리팩토링: 최종적으로 아쉬운 부분이 많았다. DB의 데이터 정확도, 구현하는 데 급급하여 덕지덕지 붙은 지저분한 코드들, 이유도 모른채 블로그에서 복사한 오래된 코드들, 시간이 부족하여 구현하지 못한 몇몇 기능들. 따라 리팩토링하기로 결심했다.

## 앞으로의 계획(리팩토링)
```
아쉬웠던 점을 개선하기 위해 조원 1명과 의기투합했다. 프로젝트가 끝나고, 주중 하루 3시간 씩 투자해서 리팩토링을 진행했다. 아래는 리팩토링에서 개선한 부분과 어려웠던 부분에 대한 기술이다.

- 개선한 부분

- 어려웠던 부분
```